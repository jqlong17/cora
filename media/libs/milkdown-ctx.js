/* esm.sh - @milkdown/ctx@7.18.0 */
var a=(n=>(n.docTypeError="docTypeError",n.contextNotFound="contextNotFound",n.timerNotFound="timerNotFound",n.ctxCallOutOfScope="ctxCallOutOfScope",n.createNodeInParserFail="createNodeInParserFail",n.stackOverFlow="stackOverFlow",n.parserMatchError="parserMatchError",n.serializerMatchError="serializerMatchError",n.getAtomFromSchemaFail="getAtomFromSchemaFail",n.expectDomTypeError="expectDomTypeError",n.callCommandBeforeEditorView="callCommandBeforeEditorView",n.missingRootElement="missingRootElement",n.missingNodeInSchema="missingNodeInSchema",n.missingMarkInSchema="missingMarkInSchema",n.ctxNotBind="ctxNotBind",n.missingYjsDoc="missingYjsDoc",n))(a||{}),o=class extends Error{constructor(e,i){super(i),this.name="MilkdownError",this.code=e}};function f(n){return new o(a.contextNotFound,`Context "${n}" not found, do you forget to inject it?`)}function p(n){return new o(a.timerNotFound,`Timer "${n}" not found, do you forget to record it?`)}function g(){return new o(a.ctxCallOutOfScope,"Should not call a context out of the plugin.")}var w=class{constructor(){this.sliceMap=new Map,this.get=e=>{let i=typeof e=="string"?[...this.sliceMap.values()].find(r=>r.type.name===e):this.sliceMap.get(e.id);if(!i){let r=typeof e=="string"?e:e.name;throw f(r)}return i},this.remove=e=>{let i=typeof e=="string"?[...this.sliceMap.values()].find(r=>r.type.name===e):this.sliceMap.get(e.id);i&&this.sliceMap.delete(i.type.id)},this.has=e=>typeof e=="string"?[...this.sliceMap.values()].some(i=>i.type.name===e):this.sliceMap.has(e.id)}},c=class{constructor(e,i,r){this.#t=[],this.#n=()=>{this.#t.forEach(t=>t(this.#e))},this.set=t=>{this.#e=t,this.#n()},this.get=()=>this.#e,this.update=t=>{this.#e=t(this.#e),this.#n()},this.type=r,this.#e=i,e.set(r.id,this)}#t;#e;#n;on(e){return this.#t.push(e),()=>{this.#t=this.#t.filter(i=>i!==e)}}once(e){let i=this.on(r=>{e(r),i()});return i}off(e){this.#t=this.#t.filter(i=>i!==e)}offAll(){this.#t=[]}},u=class{constructor(e,i){this.id=Symbol(`Context-${i}`),this.name=i,this._defaultValue=e,this._typeInfo=()=>{throw g()}}create(e,i=this._defaultValue){return new c(e,i,this)}},v=(n,e)=>new u(n,e),m=class{constructor(e,i,r){this.#i=new Set,this.#r=new Set,this.#s=new Map,this.#o=new Map,this.read=()=>({metadata:this.#t,injectedSlices:[...this.#i].map(t=>({name:typeof t=="string"?t:t.name,value:this.#a(t)})),consumedSlices:[...this.#r].map(t=>({name:typeof t=="string"?t:t.name,value:this.#a(t)})),recordedTimers:[...this.#s].map(([t,{duration:s}])=>({name:t.name,duration:s,status:this.#h(t)})),waitTimers:[...this.#o].map(([t,{duration:s}])=>({name:t.name,duration:s,status:this.#h(t)}))}),this.onRecord=t=>{this.#s.set(t,{start:Date.now(),duration:0})},this.onClear=t=>{this.#s.delete(t)},this.onDone=t=>{let s=this.#s.get(t);s&&(s.duration=Date.now()-s.start)},this.onWait=(t,s)=>{let h=Date.now();s.finally(()=>{this.#o.set(t,{duration:Date.now()-h})}).catch(console.error)},this.onInject=t=>{this.#i.add(t)},this.onRemove=t=>{this.#i.delete(t)},this.onUse=t=>{this.#r.add(t)},this.#a=t=>this.#e.get(t).get(),this.#h=t=>this.#n.get(t).status,this.#e=e,this.#n=i,this.#t=r}#t;#e;#n;#i;#r;#s;#o;#a;#h},y=class n{constructor(e,i,r){this.produce=t=>t&&Object.keys(t).length?new n(this.#t,this.#e,{...t}):this,this.inject=(t,s)=>{let h=t.create(this.#t.sliceMap);return s!=null&&h.set(s),this.#i?.onInject(t),this},this.remove=t=>(this.#t.remove(t),this.#i?.onRemove(t),this),this.record=t=>(t.create(this.#e.store),this.#i?.onRecord(t),this),this.clearTimer=t=>(this.#e.remove(t),this.#i?.onClear(t),this),this.isInjected=t=>this.#t.has(t),this.isRecorded=t=>this.#e.has(t),this.use=t=>(this.#i?.onUse(t),this.#t.get(t)),this.get=t=>this.use(t).get(),this.set=(t,s)=>this.use(t).set(s),this.update=(t,s)=>this.use(t).update(s),this.timer=t=>this.#e.get(t),this.done=t=>{this.timer(t).done(),this.#i?.onDone(t)},this.wait=t=>{let s=this.timer(t).start();return this.#i?.onWait(t,s),s},this.waitTimers=async t=>{await Promise.all(this.get(t).map(s=>this.wait(s)))},this.#t=e,this.#e=i,this.#n=r,r&&(this.#i=new m(e,i,r))}#t;#e;#n;#i;get meta(){return this.#n}get inspector(){return this.#i}},S=class{constructor(){this.store=new Map,this.get=e=>{let i=this.store.get(e.id);if(!i)throw p(e.name);return i},this.remove=e=>{this.store.delete(e.id)},this.has=e=>this.store.has(e.id)}},d=class{constructor(e,i){this.#t=null,this.#e=null,this.#i="pending",this.start=()=>(this.#t??=new Promise((r,t)=>{this.#e=s=>{s instanceof CustomEvent&&s.detail.id===this.#n&&(this.#i="resolved",this.#r(),s.stopImmediatePropagation(),r())},this.#s(()=>{this.#i==="pending"&&(this.#i="rejected"),this.#r(),t(new Error(`Timing ${this.type.name} timeout.`))}),this.#i="pending",addEventListener(this.type.name,this.#e)}),this.#t),this.done=()=>{let r=new CustomEvent(this.type.name,{detail:{id:this.#n}});dispatchEvent(r)},this.#r=()=>{this.#e&&removeEventListener(this.type.name,this.#e)},this.#s=r=>{setTimeout(()=>{r()},this.type.timeout)},this.#n=Symbol(i.name),this.type=i,e.set(i.id,this)}#t;#e;#n;#i;get status(){return this.#i}#r;#s},l=class{constructor(e,i=3e3){this.create=r=>new d(r,this),this.id=Symbol(`Timer-${e}`),this.name=e,this.timeout=i}},F=(n,e=3e3)=>new l(n,e);export{S as Clock,w as Container,y as Ctx,m as Inspector,c as Slice,u as SliceType,d as Timer,l as TimerType,v as createSlice,F as createTimer};
//# sourceMappingURL=ctx.bundle.mjs.map